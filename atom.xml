<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://clyzwangyuyang.github.io</id>
    <title>Gridea</title>
    <updated>2020-02-29T13:18:36.526Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://clyzwangyuyang.github.io"/>
    <link rel="self" href="https://clyzwangyuyang.github.io/atom.xml"/>
    <subtitle>书是我最好的朋友。</subtitle>
    <logo>https://clyzwangyuyang.github.io/images/avatar.png</logo>
    <icon>https://clyzwangyuyang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[牛站]]></title>
        <id>https://clyzwangyuyang.github.io/post/niu-zhan/</id>
        <link href="https://clyzwangyuyang.github.io/post/niu-zhan/">
        </link>
        <updated>2020-02-29T11:47:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>给定一张由T条边构成的无向图，点的编号为1~1000之间的整数。<br>
求从起点S到终点E恰好经过N条边（可以重复经过）的最短路。</p>
<p>数据范围:<br>
2≤T≤100,<br>
2≤N≤106</p>
<h2 id="analyz">Analyz:</h2>
<h3 id="算法1-bellman-ford算法-ont">算法1： Bellman-Ford算法 O(NT)</h3>
<p>可以进行N次Bellman-Ford算法，求出恰好经过N条边的最短路。每次求的时候dis数组要清空。</p>
<h3 id="算法2-倍增-ot3-log-n">算法2： 倍增 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">T^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> log N )</h3>
<p>d[i][j][c]表示从i到j经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">2^c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span></span></span>条边的最短路<br>
d[i][j][c] = min{ d[i][k][c - 1] + d[k][j][c - 1] }<br>
最后将N进行二进制分解，进行合并。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msub><mi>c</mi><mn>3</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><msub><mi>c</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub><mo>∗</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">N = c_1 * 2 ^ 0  +  c_2 * 2 ^ 1 +  c_3 * 2 ^ 2 + \dots c_{k - 1} * 2 ^ {k } + c_k * 2 ^ {k + 1} + ... \dots
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.673611em;vertical-align:-0.208331em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span></p>
<p>假设当前已经进行到第 k +１步<br>
g[i]表示经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msub><mi>c</mi><mn>3</mn></msub><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msub><mi>c</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">c_1 * 2 ^ 0  +  c_2 * 2 ^ 1 +  c_3 * 2 ^ 2 +  c_{k - 1} * 2 ^ {k }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.673611em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>步的最短路，f[i]表示经过$ c_1 * 2 ^ 0  +  c_2 * 2 ^ 1 +  c_3 * 2 ^ 2 +.....c{k - 1} * 2 ^ {k } + c_k * 2 ^ {k + 1}$步的最短路，那么<br>
f[i] = min { g[k]  + d [ k ][ i ][ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ]},也就是在当前基础上在走<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mi>c</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">2^{c_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>步。</p>
<h3 id="算法3-倍增-ot3-log-n">算法3: 倍增 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">T^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> log N)</h3>
<p>d[a + b][i][j]表示恰好经过a +ｂ条边的最短路。那么d[a + b][i][j] = d[a][i][k] + d[b][k][j],我们也可以通过倍增来进行优化。</p>
<pre><code class="language-cpp">
//算法1
#pragma GCC optimize(2)
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#define gc getchar()

using namespace std;

const int N = 2e2 + 10;
int m, edges, st, ed;
int raw[N], tot, dis[N], dis2[N];
struct Edge {
	int u, v, w;
} e[N];

inline int read() {
	int x = 0, sgn = 1; char ch = gc;
	while( !isdigit(ch)) { if( ch == '-') sgn = -1; ch = gc; }
	while( isdigit(ch)) {  x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = gc; }
	return x * sgn;
}

int find(int val) {
	return lower_bound(raw + 1, raw + tot + 1, val) - raw;
}

void Bellman_ford()
{
	memset(dis, 0x3f, sizeof(dis));
	memset(dis2, 0x3f, sizeof(dis2));
	dis2[st] = 0;
	for(int i = 1; i &lt;= m; i ++) {
		memset(dis, 0x3f, sizeof(dis));
		for(int j = 1; j &lt;= tot; j ++) {
		    int u = e[j].u, v = e[j].v;
			dis[v] = min(dis[v], dis2[u] + e[j].w);
		}
		memcpy(dis2, dis, sizeof(dis));
	}
	printf(&quot;%d\n&quot;, dis[ed]);
}

int main()
{
	m = read(), edges = read(), st = read(), ed = read();
	for(int i = 1; i &lt;= edges; i ++ ) {
		int u, v, w;
		w = read(), u = read(), v = read();
		e[ ++ tot].w = w, e[tot].u = u, e[tot].v = v, raw[tot] = u;
		e[ ++ tot].w = w, e[tot].v = u, e[tot].u = v, raw[tot] = v;
	}
	sort(raw + 1, raw + tot + 1);
	int m = unique(raw + 1, raw + tot + 1) - (raw + 1);
	st = find(st), ed = find(ed);
	for(int i = 1; i &lt;= tot; i ++) {
	    e[i].u = find(e[i].u), e[i].v = find(e[i].v);
	}
	Bellman_ford();
	return 0;
}


//算法二

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 205, M = 105;
struct Edge{
    int u, v, w;
}e[M];
int m, n, s, t, adj[N], tot, d[N][N][20], f[N], g[N];
int L;

int inline get(int x) {
    return lower_bound(adj + 1, adj + 1 + tot, x) - adj;
}
int main(){
    memset(d, 0x3f, sizeof d);
    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);
    L = log2(n);
    for (int i = 1; i &lt;= m; i++) {
        scanf(&quot;%d%d%d&quot;, &amp;e[i].w, &amp;e[i].u, &amp;e[i].v);
        adj[++tot] = e[i].u;
        adj[++tot] = e[i].v;
    }
    sort(adj + 1, adj + 1 + tot);
    tot = unique(adj + 1, adj + 1 + tot) - adj - 1;
    for (int i = 1; i &lt;= m; i++) {
        int u = get(e[i].u), v = get(e[i].v), w = e[i].w;
        d[u][v][0] = d[v][u][0] = min(d[u][v][0], w);
    }
    s = get(s), t = get(t);

    for (int c = 1; c &lt;= L; c++) {
        for (int i = 1; i &lt;= tot; i++) {
            for (int j = 1; j &lt;= tot; j++) {
                for (int k = 1; k &lt;= tot; k++) {
                    d[i][j][c] = min(d[i][j][c], d[i][k][c - 1] + d[k][j][c - 1]);
                }
            }
        }
    }

    memset(g, 0x3f, sizeof g);
    g[s] = 0;
    for (int c = 0; c &lt;= L; c++) {
        if(n &gt;&gt; c &amp; 1) {
            memset(f, 0x3f, sizeof f);
            for (int i = 1; i &lt;= tot; i++) 
                for (int j = 1; j &lt;= tot; j++)
                    f[i] = min(f[i], g[j] + d[j][i][c]);
            memcpy(g, f, sizeof g);
        }
    }
    printf(&quot;%d\n&quot;, f[t]);
    return 0;
}

//算法3:

#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
using namespace std;

const int N = 110;

int g[N][N], res[N][N];
int n, m, K, s, e;
map&lt;int, int&gt; ids;

void mul(int c[][N], int a[][N], int b[][N])
{
	static int tmp[N][N];
	memset(tmp, 0x3f, sizeof(tmp));
	for(int k = 1; k &lt;= n; k ++)
	    for(int i = 1; i &lt;= n; i ++)
	        for(int j = 1; j &lt;= n; j ++)
	            tmp[i][j] = min(tmp[i][j], a[i][k] + b[k][j]);
    memcpy(c, tmp, sizeof(tmp));
}

void qpow()
{
	memset(res, 0x3f, sizeof(res));
	for(int i = 1; i &lt;= n; i ++)  res[i][i] = 0;//经过 0 条边的最短路 
	for(; K; K &gt;&gt;= 1) {
		if( K &amp; 1)  mul(res, res, g);
		mul(g, g, g);
	}
}

int main()
{
	scanf(&quot;%d%d%d%d&quot;, &amp;K, &amp;m, &amp;s, &amp;e);
	memset(g, 0x3f, sizeof(g));
	for(int i = 1; i &lt;= m; i ++) {
		int w, u, v;
		scanf(&quot;%d%d%d&quot;, &amp;w, &amp;u, &amp;v);
		if( !ids.count(u))  ids[u] = ++n;
		if( !ids.count(v))  ids[v] = ++n;
		u = ids[u], v = ids[v];
		g[u][v] = g[v][u] = min( g[u][v], w);
	}
	s = ids[s], e = ids[e];
	qpow();
	printf(&quot;%d\n&quot;, res[s][e]);
	return 0;
} 

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NOI1997最优乘车]]></title>
        <id>https://clyzwangyuyang.github.io/post/noi1997-zui-you-cheng-che/</id>
        <link href="https://clyzwangyuyang.github.io/post/noi1997-zui-you-cheng-che/">
        </link>
        <updated>2020-02-28T12:12:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>H城是一个旅游胜地，每年都有成千上万的人前来观光。<br>
为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。<br>
每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。<br>
一名旅客最近到H城旅游，他很想去S公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达S公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士, 这样换乘几次后到达S公园。<br>
现在用整数1,2,…N 给H城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为1，S公园巴士站的编号为N。<br>
写一个程序，帮助这名旅客寻找一个最优乘车方案,使他在从饭店乘车到S公园的过程中换乘的次数最少。</p>
<p>输入格式:<br>
第一行有两个数字M和N，表示开通了M条单程巴士线路，总共有N个车站。<br>
从第二行到第M+1行依次给出了第1条到第M条巴士线路的信息，其中第i+1行给出的是第i条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。</p>
<p>输出格式<br>
共一行，如果无法乘巴士从饭店到达S公园，则输出”NO”，否则输出最少换乘次数，换乘次数为0表示不需换车即可到达。</p>
<p>数据范围<br>
1≤M≤100,<br>
1≤N≤500</p>
<h2 id="analyz">Analyz:</h2>
<p>将问题转化一下，最优换乘次数 = 最少乘车次数 - 1， 那么如何求最少乘车次数呢？ 依次枚举每一条公交线路，如果A能到B，就连一条A到B的有向边，边权为1，表示A到B需要乘坐一辆车。最后用bfs求最短路或者Dijkstra求最短路就可以了。复杂度O(M * N ^ 2 ).</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POJ 昂贵的聘礼]]></title>
        <id>https://clyzwangyuyang.github.io/post/poj-ang-gui-de-pin-li/</id>
        <link href="https://clyzwangyuyang.github.io/post/poj-ang-gui-de-pin-li/">
        </link>
        <updated>2020-02-28T11:30:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>年轻的探险家来到了一个印第安部落里。</p>
<p>在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p>
<p>酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。</p>
<p>探险家拿不出这么多金币，便请求酋长降低要求。</p>
<p>酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”</p>
<p>探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。</p>
<p>探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。</p>
<p>不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。</p>
<p>探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。</p>
<p>另外他要告诉你的是，在这个部落里，等级观念十分森严。</p>
<p>地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。</p>
<p>他是一个外来人，所以可以不受这些限制。</p>
<p>但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。</p>
<p>因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p>
<p>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。</p>
<p>每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。</p>
<p>如果两人地位等级差距超过了M，就不能”间接交易”。</p>
<p>你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p>输入格式<br>
输入第一行是两个整数M，N，依次表示地位等级差距限制和物品的总数。</p>
<p>接下来按照编号从小到大依次给出了N个物品的描述。</p>
<p>每个物品的描述开头是三个非负整数P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。</p>
<p>接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<p>输出格式<br>
输出最少需要的金币数。</p>
<p>数据范围:<br>
1≤N≤100,<br>
1≤P≤10000,<br>
1≤L,M≤ N,<br>
0≤X&lt; N</p>
<h2 id="analyz">Analyz:</h2>
<p>题目中最关键的信息就是，一个物品可以用其他物品来替代，那么转化一下，就变成：如果Ａ可以用Ｂ来替代，那么就连一条从B到A的有向边。最后，建立一个超级源点，从源点向每个点连一条有向边,权值为直接购买该商品的价格。那么最终的答案为从超级源点到一号点的最短路, 复杂度为O(N^2 ), 最朴素的 djkstra。但是题目中还有一个等级差距限制，我们发现M的范围比较小，可以直接暴力枚举等级交易区间，就是只跟等级区间在[L,R]中的人交易，复杂度为O( N^2 )，总复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;

using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 100 + 10, INF = 1e9 + 7;
int m, n;
int g[N][N], grade[N], dis[N];
bool vis[N];
vector&lt;PII&gt; vec[N];//替代品的编号 , 优惠价格 

void Build()
{
	for(int i = 1; i &lt;= n; i ++) {
		for(int j = 0, sz = vec[i].size(); j &lt; sz; j ++) {
			int v = vec[i][j].first, w = vec[i][j].second;
			g[v][i] = w;
		}
	}
}

int Dijkstra(int l, int r)
{
	memset(vis, 0, sizeof(vis));
	memset(dis, 0x3f, sizeof(dis));
	dis[0] = 0;
	for(int i = 1; i &lt;= n; i ++) {
		int x = n + 1;
		for(int j = 0; j &lt;= n; j ++) 
		    if( !vis[j] &amp;&amp; ( x == n + 1 || dis[j] &lt; dis[x])) x = j;
        vis[x] = true;
        for(int y = 1; y &lt;= n; y ++)
        	if( dis[y] &gt; dis[x] + g[x][y] &amp;&amp; grade[y] &gt;= l &amp;&amp; grade[y] &lt;= r)
        	    dis[y] =  dis[x] + g[x][y];
	}
	return dis[1];
}

int main()
{
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	memset(g, 0x3f, sizeof(g));
	for(int i = 1; i &lt;= n; i ++) {
		int w, cnt;
		scanf(&quot;%d%d%d&quot;, &amp;w, &amp;grade[i], &amp;cnt);
		g[0][i] = w;
		while(cnt --) {
			int p;
			scanf(&quot;%d%d&quot;, &amp;p, &amp;w);
			vec[i].push_back(make_pair(p, w));
		}
	}
	Build();//建图 
	int res = INF;
	for(int i = 1; i &lt;= n; i ++) {
		for(int j = i; j &lt;= n &amp;&amp; j - i &lt;= m; j ++)
		    res = min( Dijkstra(i, j), res);
	}
	printf(&quot;%d\n&quot;, res);
	return 0;
} 

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OI刷题计划]]></title>
        <id>https://clyzwangyuyang.github.io/post/oi-shua-ti-ji-hua/</id>
        <link href="https://clyzwangyuyang.github.io/post/oi-shua-ti-ji-hua/">
        </link>
        <updated>2020-02-28T10:50:04.000Z</updated>
        <content type="html"><![CDATA[<p>动态规划DP:奇数日<br>
进阶指南, 训练指南，入门经典DP问题</p>
<p>数学：偶数日<br>
Acwing算法提高课<br>
上交组合数学<br>
进阶指南, 训练指南，入门经典数学问题</p>
<p>上午:<br>
11:00  -- 13 : 00<br>
晚上:<br>
6:00 - 9:00</p>
<p>数据结构，图论。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [USACO06FEB]奶牛零食]]></title>
        <id>https://clyzwangyuyang.github.io/post/usaco06febnai-niu-ling-shi/</id>
        <link href="https://clyzwangyuyang.github.io/post/usaco06febnai-niu-ling-shi/">
        </link>
        <updated>2020-02-27T04:42:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>约翰经常给产奶量高的奶牛发特殊津贴，于是很快奶牛们拥有了大笔不知该怎么花的钱．为此，约翰购置了N(1≤N≤2000)份美味的零食来卖给奶牛们．每天约翰售出一份零食．当然约翰希望这些零食全部售出后能得到最大的收益．这些零食有以下这些有趣的特性：</p>
<p>•零食按照1．．N编号，它们被排成一列放在一个很长的盒子里．盒子的两端都有开口，约翰每<br>
天可以从盒子的任一端取出最外面的一个．<br>
•与美酒与好吃的奶酪相似，这些零食储存得越久就越好吃．当然，这样约翰就可以把它们卖出更高的价钱．<br>
•每份零食的初始价值不一定相同．约翰进货时，第i份零食的初始价值为Vi(1≤Vi≤1000)．<br>
•第i份零食如果在被买进后的第a天出售，则它的售价是vi×a．</p>
<p>Vi的是从盒子顶端往下的第i份零食的初始价值．约翰告诉了你所有零食的初始价值，并希望你能帮他计算一下，在这些零食全被卖出后，他最多能得到多少钱．</p>
<h2 id="analyze">Analyze:</h2>
<p>剩余的零食是一个不断减少的区间，可以考虑区间DP。设f[l][r]表示将区间[l,r]的零食卖掉的最大价值。但是这样很难去转移。因为两端都可以卖零食，我们可以让头与尾对接，也就是将区间加倍， a[n + i ] = a[i]。f[l][r]就表示横跨区间的[l,r]最大价值。那么最后卖出的一定是l或者r，因为卖零食一定是从n与n + 1处向两边扩展。转移方程:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>∗</mo><mi>a</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>∗</mo><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>)</mo><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">f[l][r] = max(f[l][r], max(f[l + 1][r] + len * a[l], f[l][r - 1] + len * a[r])); 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p>
<p>其中，len = r - l + 1</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

const int N = 4e3 + 100, INF = 0x3f3f3f3f;

int f[N][N];
int n, a[N];

int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		a[n + i] = a[i];
	}
	memset(f, 0xcf, sizeof(f));
	f[n][n] = a[n], f[n + 1][n + 1] = a[n + 1];
	int ans = 0;
	for(int l = 2 * n; l &gt;= 1; -- l) {
		for(int r = l; r &lt;= 2 * n; r ++) {
			int len = r - l + 1;
			if( l &gt; n + 1 || r &lt; n || len &gt; n)  continue;
			f[l][r] = max(f[l][r], max(f[l + 1][r] + len * a[l], f[l][r - 1] + len * a[r]));
		//	printf(&quot;f[%d, %d] = %d\n&quot;, l, r, f[l][r]);
			if( len == n)  ans = max(ans, f[l][r]);
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
//53013649

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[USACO16OPEN]262144 P]]></title>
        <id>https://clyzwangyuyang.github.io/post/usaco16open262144-p/</id>
        <link href="https://clyzwangyuyang.github.io/post/usaco16open262144-p/">
        </link>
        <updated>2020-02-27T04:32:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>贝西被她最近玩的一款游戏迷住了，游戏一开始有n个正整数，(2&lt;=n&lt;=262144)，范围在1-40。在一步中，贝西可以选相邻的两个相同的数，然后合并成一个比原来的大一的数（例如两个7合并成一个8)，目标是使得最大的数最大，请帮助Bessie来求最大值。</p>
<h2 id="analyze">Analyze:</h2>
<p>方法一 ： 可以用区间DP来做， 设f[l][r][x]表示区间[l,r]的数能否合并成x ，转移:</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 29: …f[l][k][x - 1] &amp;̲&amp; f[k + 1][r][x…'>f[l][r][x] = f[l][k][x - 1] &amp;&amp; f[k + 1][r][x - 1] 
</p>
<p>还可以设计成这样的状态， f[l][r]表示区间到r能合并出的最大数, 转移：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mi>i</mi><mi>f</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[l][r] = max(f[l][r], f[l][k] + 1)  if( f[l][k] == f[k + 1][r]) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>方法二：类似与倍增，可以设f[l][x]表示从l向左， 合并出x的位置， 转移：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][x] = f[ f[ l ][x - 1] + 1][x - 1] 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>方法一:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

const int N = 300;

int a[N], n, ans;
bool f[N][N][50];

int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i ++)  scanf(&quot;%d&quot;, &amp;a[i]);
	for(int len = 1; len &lt;= n; len ++) {
		for(int l = 1; l + len - 1 &lt;= n; l ++) {
			int r = l + len - 1;
		//	printf(&quot;[%d, %d]\n&quot;, l, r);
			if( l == r) f[l][r][a[l]] = true;
			else {
				for(int num = 2; num &lt;= 49; num ++) {// f[l][r] 能否凑出数字num 
					for(int k = l; k &lt; r; k ++) {
						if( f[l][k][num - 1] &amp;&amp; f[k + 1][r][num - 1]) {
							f[l][r][num] = true;
							ans = max(ans, num);
							break;
						}
					}
				}
			}
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
<p>方法二:</p>
<pre><code class="language-cpp">/*
f[i][j] = f[f[i][j - 1][j - 1]
*/

#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

const int N = 262144 + 100;
int f[N][65];
int n, a[N], ans;

int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i ++) {
		int x;
		scanf(&quot;%d&quot;, &amp;x);
		f[i][x] = i + 1;
	}
	for(int i = n; i &gt;= 1; -- i) {
		for(int j = 2; j &lt;= 60; j ++) {
			if(! f[i][j])  f[i][j] = f[f[i][j - 1]][j - 1];
			if(f[i][j])  ans = max(ans, j);
		}
	}
	printf(&quot;%d\n&quot;, ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2010]合唱队]]></title>
        <id>https://clyzwangyuyang.github.io/post/hnoi2010he-chang-dui/</id>
        <link href="https://clyzwangyuyang.github.io/post/hnoi2010he-chang-dui/">
        </link>
        <updated>2020-02-27T03:51:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>为了在即将到来的晚会上有更好的演出效果，作为 AA 合唱队负责人的小 A 需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共 n 个人，第 i个人的身高为 hi 米（1000≤hi ≤2000），并已知任何两个人的身高都不同。假定最终排出的队形是 AA 个人站成一排，为了简化问题，小 A 想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中：</p>
<p>第一个人直接插入空的当前队形中。对从第二个人开始的每个人，如果他比前面那个人高（h 较大），那么将他插入当前队形的最右边。如果他比前面那个人矮（h 较小），那么将他插入当前队形的最左边。<br>
当 n 个人全部插入当前队形后便获得最终排出的队形。</p>
<p>小 A 心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形。</p>
<h2 id="analyze">Analyze:</h2>
<p>首先， 我们有排好的队形。每个人插入的时候是从队伍左右两端加入，整个队伍就在不断向左右两端扩展。那么就可以考虑区间DP， 区间DP是由小区间向大区间转移，而队伍也是在不断扩大。可以设f[l][r]表示区间[l,r]的人的原始队形方案，但是这样我们无法得知最后一个加入的人是l还是r。我们可以加一个参数。设f[l][r][0]表示最后一个加入的人是l， f[l][r][1]表示最后加入的人是r。如果最后加入的人是l，那么l的上一个人的位置就是 l + 1或者r.</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>∗</mo><mo>(</mo><mi>h</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>&lt;</mo><mi>h</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mo>(</mo><mi>h</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>&lt;</mo><mi>h</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[l][r][0] = f[l + 1][r][0] *(h[l] &lt; h[l + 1]) + f[l + 1][r][1] *(h[l] &lt; h[r]) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>∗</mo><mo>(</mo><mi>h</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>&gt;</mo><mi>h</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>)</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mo>(</mo><mi>h</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>&gt;</mo><mi>h</mi><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[l][r][1] = f[l][r - 1][0] * (h[r] &gt; h[l]) + f[l][r - 1][1] *(h[r] &gt; h[r - 1]) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>if  l == r, f[l][r][0] = 1,强制要求第一个人是从左边加入.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;

typedef long long LL;
const int N = 1e3 + 10, p = 19650827;

int h[N], n;
LL f[N][N][2];

int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;h[i]);
		f[i][i][0] = 1;
	}
	for(int l = n; l &gt;= 1; -- l) 
	    for(int r = l + 1; r &lt;= n; r ++) {
	    	f[l][r][0] = f[l + 1][r][0] * (h[l] &lt; h[l + 1]) % p+ f[l + 1][r][1] * (h[l] &lt; h[r]) % p;
	    	f[l][r][1] = f[l][r - 1][0] * (h[r] &gt; h[l]) % p + f[l][r - 1][1] *(h[r] &gt; h[r - 1]) % p;
	    }
	printf(&quot;%lld\n&quot;, (f[1][n][0] + f[1][n][1]) % p);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Greedy Pie Eaters P]]></title>
        <id>https://clyzwangyuyang.github.io/post/greedy-pie-eaters-p/</id>
        <link href="https://clyzwangyuyang.github.io/post/greedy-pie-eaters-p/">
        </link>
        <updated>2020-02-26T12:42:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>Farmer John 有 M 头奶牛，为了方便，编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1,\dots,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, Farmer John 一天烤了 N 个派请奶牛吃，这 N 个派编号为 1,…,N。第 i 头奶牛吃光编号在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_i, r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>中的所有派, 因此，他想让你计算，要使奶牛按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mn>1</mn><mo separator="true">,</mo><mi>c</mi><mn>2...</mn><mo>…</mo><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">c1, c2 ... \dots ck</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的顺序吃派，轮到这头奶牛时她喜欢的派至少剩余一个的情况下，这些奶牛的最大可能体重<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>w</mi><mn>1</mn><mo>+</mo><mi>w</mi><mn>2..</mn><mo>…</mo><mi>w</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(w1 + w2 ..\dots wk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>是多少？</p>
<h2 id="analyze">Analyze :</h2>
<p>首先，奶牛会吃光[l,,r]中的草，那么可以得知这道题是区间DP题，那么可以很容易得到状态， f[l][r]表示吃草区间完全在[l,r]中的奶牛的最大体重。那么，可以得到状态转移方程:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>但是， 这样并没有考虑跨区间的情况，就是吃草区间跨过k的牛。本题最难的地方就在这里。将k这个点单独考虑。可以用闫式DP分析法，从集合角度分析DP问题，　<strong>将区  间[l,r]中的牛划分为3个不相交的集合，为</strong><br>
<strong>f[l][k - 1], f[k + 1][r]和est[l][r][k],est[l][r][k]为区间在[l,r]中的奶牛并且包含的k的最大体重</strong>     。</p>
<p>可以预处理出est数组<br>
tmp = est[i][j][k]</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>t</mi><mi>m</mi><mi>p</mi><mo separator="true">,</mo><mi>e</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">est[i - 1][j][k] = max( tmp, est[i - 1][j][k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>t</mi><mi>m</mi><mi>p</mi><mo separator="true">,</mo><mi>e</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">est[i][j + 1][k] = max( tmp, est[i][j + 1][k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 300 + 10, M = N * N / 2;

int f[N][N], est[N][N][N];
int n, m;

int main()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; i ++ ) {
		int w, l, r;
		scanf(&quot;%d%d%d&quot;, &amp;w, &amp;l, &amp;r);
		for(int j = l; j &lt;= r; j ++ ) 
			est[l][r][j] = w;
	}
	for(int k = 1; k &lt;= n; k ++) {
		for(int i = k; i &gt;= 1; -- i) {
			for(int j = k; j &lt;= n; j ++) {
				int tmp = est[i][j][k];
	        	if( i != 1)  est[i - 1][j][k] = max( tmp, est[i - 1][j][k]);
                if( j != n)  est[i][j + 1][k] = max( tmp, est[i][j + 1][k]);
         //       printf(&quot;est[%d][%d][%d] = %d\n&quot;, i, j, k, est[i][j][k]);
			}
		}
	}
	for(int l = n; l &gt;= 1; l --)
	    for(int r = l; r &lt;= n; r ++) {
	    	for(int k = l; k &lt; r; k ++) 
	    		f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r]);
	    	for(int k = l; k &lt;= r; k ++) {
	    		int&amp; tmp = f[l][r];
	    		if( k == l) tmp = max(tmp, f[k + 1][r] + est[l][r][k]);
	    		if( k == r)  tmp = max(tmp, f[l][k - 1] + est[l][r][k]);
	    		f[l][r] = max(f[l][r], f[l][k - 1] + est[l][r][k] + f[k + 1][r]);
	    //		printf(&quot;est[%d][%d][%d] = %d\n&quot;, l, r, k, est[l][r][k]);
			}
		//	printf(&quot;f[%d][%d] = %d\n&quot;, l, r, f[l][r]);
		}
	printf(&quot;%d\n&quot;, f[1][n]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[USACO09MAR]牛飞盘队]]></title>
        <id>https://clyzwangyuyang.github.io/post/usaco09marniu-fei-pan-dui/</id>
        <link href="https://clyzwangyuyang.github.io/post/usaco09marniu-fei-pan-dui/">
        </link>
        <updated>2020-02-26T10:29:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description:</h2>
<p>老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的N头奶牛中选出一支队伍。</p>
<p>每只奶牛的能力为整数，第i头奶牛的能力为R i 。飞盘队的队员数量不能少于 1、大于N。一</p>
<p>支队伍的总能力就是所有队员能力的总和。</p>
<p>约翰比较迷信，他的幸运数字是F，所以他要求队伍的总能力必须是F的倍数。请帮他</p>
<p>算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span><br>
的余数就可以了。</p>
<h2 id="solution">Solution:</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>从前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个物品中选，体积和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">mod F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的方案数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[0][0] = 0, f[1][v[i] % m] = 1;
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mo>(</mo><mo>(</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = f[i - 1][j] + f[i - 1][((j - v[i]) % m + m) % m];
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

typedef long long LL;
const int N = 2e3 + 10, M = 1e3 + 10, MOD = 1e8;
int f[2][M], v[N];
int n, m;
//f[i][j]从前i个物品中选，体积和modF为j的方案数 
//f[0][0] = 0, f[1][v[i] % m] = 1;
//f[i][j] = f[i - 1][j] + f[i - 1][((j - v[i]) % m + m) % m];
int main()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; i ++) 
	    scanf(&quot;%d&quot;, &amp;v[i]);
	f[0][0] = 1;
	for(int i = 1; i &lt;= n; i ++) {   
		for(int j = 0; j &lt;= m; j ++) 
			f[i &amp; 1][j] = ( (LL) f[i - 1 &amp; 1][j] + f[i - 1 &amp; 1][( (j - v[i]) % m + m) % m]) % MOD;
	}
	printf(&quot;%d\n&quot;, f[n &amp; 1][0] - 1);
	return 0;
} 

</code></pre>
]]></content>
    </entry>
</feed>